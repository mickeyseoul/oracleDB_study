07
▷레코드 여러줄 출력하여 변수에 담을 때*** 그냥 조회 select랑은 다름!!!
select into 레코드가 한줄일 때만 가능

for i in 반복할 대상 loop 

--declare
begin
	for i in (select id, name, salary from members) loop --한 레코드씩 뽑아서 변수 i에 넣어서 출력
	dbms_output.put_line(i.id||','||i.name||','||i.salary);
	end loop;
end;
/



03
▷그룹함수
:하나 이상의 행을 그룹으로 묶어 연산하여 총합(sum), 평균(avg) 등 하나의 결과로 나타냄

급여가 500이상인 레코드를 대상으로/ 부서별 급여 평균이 2100이상인 레코드를/ 부서 오름차순으로 조회
        SLQ> select depart, avg(salary) from members
        where salary >= 500
        group by depart
        having avg(salary) >= 2000
        order by depart asc;

▶group by
일반 컬럼1, 그룹함수1, 그룹함수2 ... 	--일반컬럼, 그룹함수 함께 있을땐 group by 필수***
group by 일반컬럼1;

일반 컬럼1, 일반컬럼2, 그룹함수1, 그룹함수2 ...
group by 일반컬럼1, 일반컬럼2; 		   --일반컬럼 수 맞춰야 함

select name, to_char(sysdate,'yyyy') - to_char(birth,'yyyy') as age from members --
where to_char(sysdate,'yyyy') - to_char(birth,'yyyy')>=40;
Xselect name, to_char(sysdate,'yyyy') - to_char(birth,'yyyy') as age from members  
where age>=40; --age 컬럼은 임시이기 때문에 안됨***


04 
SQL> select depart, avg(salary) 
          2  from members;
        select depart, avg(salary)
               *
        1행에 오류:
        ORA-00937: 단일 그룹의 그룹 함수가 아닙니다 
--그룹함수와 일반 컬럼을 같이 조회하는 경우에는 group by로 묶어주어야 함 ***


where
having --조건문 일반컬럼/ 함수
급여가 500이상인 레코드를 대상으로/ 급여 평균이 2100이상인 레코드 부서별 조회  --<having
        SLQ> select depart, avg(salary) from members
        where salary >= 500
        group by depart
        having avg(salary) >= 2000;


select pro.code, p_name, c_name, c_addr
from producer pro, consumer con               --테이블 별칭 설정 as 절대 안됨***
where pro.code = con.code;


06
--declare

Begin
	update consumer
	set c_name = '&c_name' ,'&c_price --변수선언 없이 바로 입력 받을 수 있음***
	where code='&code';
End;
/




